fn test_u8_arith(a: u8, b: u8) -> u8 {
  2+b+a-3
}
fn test_u16_arith(a: u16, b: u16, c: u16, d: u8) -> u16 {
  a + b + c - 0x10f0u16 & 0x33cc | 0xf00f ^ d as u16
}
fn test_cast_u16(a: u8) -> u16 { a as u16 }

fn test_cast_u8(a: u16) -> u8 { a as u8 }

fn test_u16_global() -> void {
    test_u16 = 10u16;
    test_u16 = test_u16 + test_u16;
    test_u16 = test_u16 + 1u16;
    if test_u16 - 21u16 {
        fail_();
    } else {
        pass();
    }
}

var passes: u8;
var fails: u8;

var test_u16: u16;

fn pass() { passes = passes + 1; }
fn fail_() { fails = fails + 1; } // seems 'fail' is an rgbasm special thing...

fn main() -> void {
    passes = fails = 0;

    if test_u8_arith(4,0xf) - 0x12 {
        fail_()
    } else {
        pass()
    };

    if test_u16_arith(0x6543, 0x4567, 0x1234, 0x20) - 0xf3ef {
        fail_()
    } else {
        pass()
    };

    if test_cast_u16(0xde) - 0xdeu16 {
        fail_()
    } else {
        pass()
    };

    if test_cast_u8(0xcafe) - 0xfe {
        fail_()
    } else {
        pass()
    };

    // test multiply
    if 5*5 - 25 { fail_() } else { pass() };
    if 255*255 - 1 { fail_() } else { pass() };
    if 255u16*255u16 - 0xfe01 { fail_() } else { pass() };
    if 123u16*100u16 - 12300 { fail_() } else { pass() };

    test_u16_global();

    output_results();
}

/* Show passed tests in reg 'a', failed tests in 'b' */
fn output_results() {
    asm("
         ld hl, passes
         ld a, [hl]
         ld hl, fails
         ld b, [hl]
         db $dd");
}
